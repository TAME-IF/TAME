===============================================================================
================================ TAME COMMANDS ================================
===============================================================================

All Commands in this file are available for use when writing TAME modules.
Every command's name is case-insensitive.

TAME attempts to mitigate infinite loops: if 100000 commands are executed in 
a single request, the request is terminated. The game state is NOT RESTORED 
AFTERWARDS if this happens, so fix your code if this occurs!

Argument Types
--------------

VALUE(1/2):	Literal or Variable or expression; can be Number or String unless 
			specified.
WORLD:		A valid world or "world" (current world). Actually, there is only 
			one world.
ROOM:		A valid room or "room" (current room).
PLAYER:		A valid player or "player" (current player).
OBJECT:		A valid object.
CONTAINER:	A valid container.

...............................................................................
................................   RESPONSE  ..................................
...............................................................................

ADDCUE(VALUE1, VALUE2)

	VALUE1: The cue name, string value.
	VALUE2: The cue value, any type.
	
	ADDCUE returns no values after execution.
	
	Adds a cue to the response to be read later by the client that sent the 
	original request. Clients process cues in the order that they were added.

	See CUES for a list of valid client cues (can differ by client type).
	
...............................................................................

TEXT(VALUE)

	VALUE: The message to print.
	
	Appends a "text" cue to the response. 

	TEXT returns no values after execution, so it cannot be used in 
	expressions.
	
	Equivalent to:
	ADDCUE("text", VALUE);
	
...............................................................................

TEXTLN(VALUE)

	VALUE: The message to print.
	
	Appends a "text" cue to the response with a newline character appended to 
	the end. 

	TEXTLN returns no values after execution, so it cannot be used in 
	expressions.
	
	Equivalent to:
	ADDCUE("text", VALUE+"\n");
	
...............................................................................

TEXTF(VALUE)

	VALUE: The message to print.
	
	Appends a "textf" cue to the response. 

	TEXT returns no values after execution, so it cannot be used in 
	expressions.
	
	Equivalent to:
	ADDCUE("textf", VALUE);
	
...............................................................................

TEXTFLN(VALUE)

	VALUE: The message to print.
	
	Appends a "textf" cue to the response with a newline character appended to 
	the end. 

	TEXTLN returns no values after execution, so it cannot be used in 
	expressions.
	
	Equivalent to:
	ADDCUE("textf", VALUE+"\n");
	
...............................................................................

WAIT(VALUE)
	
	VALUE: The time in milliseconds to wait. If string, this is parsed as an 
	integer.
	
	Appends a "wait" cue to the response, which tells the client to wait a 
	given amount of milliseconds before continuing processing. Even though
	this cue is understood by all clients, a client medium may not allow this 
	to happen as intended due to limitations in implementation.
	
	WAIT returns no values after execution, so it cannot be used in 
	expressions.

	Equivalent to:
	ADDCUE("wait", VALUE);
	
...............................................................................

PAUSE()
	
	Appends a "pause" cue to the response, which tells the client to wait for 
	user confirmation before continuing. Even though this cue is understood by 
	all clients, a client medium may not allow this to happen as intended due to 
	limitations in implementation.
	
	PAUSE returns no values after execution, so it cannot be used in 
	expressions.

	Equivalent to:
	ADDCUE("pause", "");
	
...............................................................................

TIP(VALUE)
	
	VALUE: A literal or variable or expression, numeric or string.
	
	Appends a "tip" cue to the response.
	
	TIP returns no values after execution, so it cannot be used in 
	expressions.

	Equivalent to:
	ADDCUE("tip", VALUE);
	
...............................................................................

INFO(VALUE)
	
	VALUE: A literal or variable or expression, numeric or string.
	
	Appends an "info" cue to the response.
	
	INFO returns no values after execution, so it cannot be used in 
	expressions.

	Equivalent to:
	ADDCUE("info", VALUE);
	
...............................................................................
................................   CONTROL   ..................................
...............................................................................

IF(VALUE) { ... }

	VALUE: A literal or variable or expression, numeric or string.
	
	IF is a code block, and cannot be used in expressions.
	
	Executes the encapsulated block of commands if VALUE evaluates to TRUE,
	which is a non-string, non-zero number. This is usually an evaluative 
	expression of some kind, like x == 10 or the like. If the expression is
	FALSE (not TRUE), the block is not executed.

	Can be accompanied with an ELSE command.

...............................................................................

ELSE { ... }

	Takes no arguments. If used, it must follow an IF command and its 
	accompanying code block.

	ELSE is a code block, and cannot be used in expressions.

	Executes the encapsulated block of commands if the previous IF statement
	evaluates to FALSE, which is a string type, or a zero result. If the 
	previous IF statement evaluates to TRUE, the block is not executed.

...............................................................................

WHILE(VALUE) { ... }

	VALUE: A literal or variable or expression, numeric or string.
	
	WHILE is a code block, and cannot be used in expressions.

	Executes the encapsulated block of commands if VALUE evaluates to TRUE,
	which is a non-string, non-zero number. This is usually an evaluative 
	expression of some kind, like x == 10 or the like. If the expression is
	FALSE (not TRUE), the block is not executed.
	
	After the block is finished, the value/expression is evaluated again, and
	Re-executes the block if it is still TRUE.
	
	A WHILE block can be escaped using a BREAK command.

...............................................................................

BREAK

	If a BREAK command is executed, execution of the current loopable block of
	code (inside WHILE or UNTIL) will cease. 

	A BREAK command takes no arguments. 
	
	BREAK returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

CANCEL

	Similar to BREAK, except it can break out of whole requests. Be careful
	when using this command, as it may leave a request in an incomplete state
	and does not reverse requests.

	A CANCEL command takes no arguments. 
	
	CANCEL returns no values after execution, so it cannot be used in 
	expressions.

...............................................................................

CONTINUE

	When CONTINUE is used inside a loopable block of code (inside WHILE or 
	UNTIL), it will immediately jump to the beginning of the loop, as though
	the current iteration had finished.

	A CONTINUE command takes no arguments. 
	
	CONTINUE returns no values after execution, so it cannot be used in 
	expressions.

...............................................................................

QUIT

	Puts a QUIT cue into the response and aborts execution.

	This is NOT THE SAME as calling:
	ADDCUE("quit",0); 
	
	...as that command does not interrupt the current request.

	A QUIT command takes no arguments. 

	QUIT returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

QUEUEACTION(ACTION)

	Enqueues an action to be processed later after an action completes.
	
	QUEUEACTION returns no values after execution, so it cannot be used in 
	expressions.

	ACTION can be any action, but problems may occur if it is not a GENERAL
	action. QUEUEACTION does not interrupt the current flow of execution.

...............................................................................

QUEUEACTIONSTRING(ACTION, VALUE)

	Enqueues an action to be processed later after an action completes.
	
	QUEUEACTIONSTRING returns no values after execution, so it cannot be used 
	in expressions.

	ACTION can be any action, but problems may occur if it is not a GENERAL,
	OPEN, or MODAL action. QUEUEACTIONSTRING does not interrupt the current 
	flow of execution.
	
	VALUE must be the target that normally accompanies an OPEN or MODAL action. 

...............................................................................

QUEUEACTIONOBJECT(ACTION, OBJECT)

	Enqueues an action to be processed later after an action completes.
	
	QUEUEACTIONOBJECT returns no values after execution, so it cannot be used 
	in expressions.

	ACTION can be any action, but problems may occur if it is not a GENERAL,
	TRANSITIVE, or DITRANSITIVE action. QUEUEACTIONOBJECT does not interrupt 
	the current flow of execution.
	
	OBJECT must be the target object that would normally accompany a TRANSITIVE
	or DITRANSITIVE action.

...............................................................................

QUEUEACTIONOBJECT2(ACTION, OBJECT1, OBJECT2)

	Enqueues an action to be processed later after an action completes.
	
	QUEUEACTIONOBJECT2 returns no values after execution, so it cannot be 
	used in expressions.

	ACTION can be any action, but problems may occur if it is not a GENERAL,
	TRANSITIVE, or DITRANSITIVE action. QUEUEACTIONOBJECT2 does not interrupt 
	the current flow of execution.
	
	OBJECT(1/2) must be the target objects that normally accompany a 
	TRANSITIVE or DITRANSITIVE action.

...............................................................................
................................   OBJECTS   ..................................
...............................................................................

OBJECTSINWORLDCOUNT()

	Returns the amount of objects owned by the world as an integer value.
	
	NOTE: An object with no owner is NOT owned by the world!

...............................................................................

OBJECTSINCONTAINERCOUNT(PLAYER)

	Returns the amount of objects owned by a container as an integer value.
	
	CONTAINER can be any Container object.

...............................................................................

OBJECTSINPLAYERCOUNT(PLAYER)

	Returns the amount of objects owned by a player as an integer value.
	
	PLAYER can be any Player object, including "player", which is the currently
	focused player.

...............................................................................

OBJECTSINROOMCOUNT(ROOM)

	Returns the amount of objects owned by a room as an integer value.

	ROOM can be any Room object, including "room", which is the currently
	focused room.

...............................................................................

ADDOBJECTNAME(OBJECT, VALUE)

	Adds a name to an object. This name is for requests parsed by the 
	interpreter, and has nothing to do with the name given to the object as it
	is defined for the compiler.
	
	ADDOBJECTNAME is usually used when you are adding specifity to an ambiguous
	object, for instance if the player finds a "small key," but once it is
	used, it can be referred to now as the "front door key" or something.

	ADDOBJECTNAME returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

GIVECONTAINEROBJECT(CONTAINER, OBJECT)

	Sets the ownership of an OBJECT to a CONTAINER.
	
	CONTAINER can be any Container object.

	OBJECT is any Object.
	
	Objects in a Container can not be accessed, but they can be browsed.
	
	If the OBJECT had a previous owner, it is removed from the previous owner.
	
	This command influences the return value of 
	OBJECTSINCONTAINERCOUNT(CONTAINER) and CONTAINERHASOBJECT(CONTAINER, OBJECT). 

	GIVECONTAINEROBJECT returns no values after execution, so it cannot be 
	used in expressions.
	
...............................................................................

GIVEPLAYEROBJECT(PLAYER, OBJECT)

	Sets the ownership of an OBJECT to a PLAYER.
	
	PLAYER can be any Player object, including "player", which is the currently
	focused player.

	OBJECT is any Object.
	
	Objects in a Player can be accessed if the current player contains the 
	desired Object.
	
	If the OBJECT had a previous owner, it is removed from the previous owner.
	
	This command influences the return value of OBJECTSINPLAYERCOUNT(PLAYER) 
	and PLAYERHASOBJECT(PLAYER, OBJECT). 

	GIVEPLAYEROBJECT returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

GIVEROOMOBJECT(ROOM, OBJECT)

	Sets the ownership of an OBJECT to a ROOM.
	
	ROOM can be any Room object, including "room", which is the currently
	focused room.

	OBJECT is any Object.
	
	Objects in a Room can be accessed if the current player is in the same
	room containing the desired Object.
	
	If the OBJECT had a previous owner, it is removed from the previous owner.

	This command influences the return value of OBJECTSINROOMCOUNT(ROOM) 
	and ROOMHASOBJECT(ROOM, OBJECT).

	GIVEROOMOBJECT returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

GIVEWORLDOBJECT(OBJECT)

	Sets the ownership of an OBJECT to the world.
	
	OBJECT is any Object.

	Objects belonging to the world can be accessed from anywhere.

	If the OBJECT had a previous owner, it is removed from the previous owner.

	This command influences the return value of OBJECTSINWORLDCOUNT() 
	and WORLDHASOBJECT(OBJECT).

	GIVEWORLDOBJECT returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

REMOVEOBJECT(OBJECT)

	Removes ownership of an OBJECT from its current owner.
	
	OBJECT is any Object.

	If the OBJECT had no previous owner, this does nothing.

	NOTE: An object with no owner is NOT owned by the world!

	This command influences the return value of OBJECTSINWORLDCOUNT(), 
	WORLDHASOBJECT(OBJECT), OBJECTSINROOMCOUNT(ROOM), 
	ROOMHASOBJECT(ROOM, OBJECT), OBJECTSINPLAYERCOUNT(PLAYER), 
	PLAYERHASOBJECT(PLAYER, OBJECT), and OBJECTHASNOOWNER(OBJECT).

	REMOVEOBJECT returns no values after execution, so it cannot be used in 
	expressions.
	
...............................................................................

CONTAINERHASOBJECT(CONTAINER, OBJECT)

	Checks if a CONTAINER is the owner of an OBJECT. 
	
	Returns true if so, false if not.

	CONTAINER can be any Container object.
	
	OBJECT is any Object.

...............................................................................

PLAYERHASOBJECT(PLAYER, OBJECT)

	Checks if a PLAYER is the owner of an OBJECT. 
	
	Returns true if so, false if not.

	PLAYER can be any Player object, including "player", which is the currently
	focused player.
	
	OBJECT is any Object.

...............................................................................

ROOMHASOBJECT(ROOM, OBJECT)

	Checks if a ROOM is the owner of an OBJECT. 
	
	Returns true if so, false if not.

	ROOM can be any Room object, including "room", which is the currently
	focused room.
	
	OBJECT is any Object.

...............................................................................

WORLDHASOBJECT(OBJECT)

	Checks if the world is the owner of an OBJECT. 
	
	Returns true if so, false if not.

	OBJECT is any Object.

	NOTE: An object with no owner is NOT owned by the world!

...............................................................................

OBJECTHASNOOWNER(OBJECT)

	Checks if an object has no owner. 
	
	Returns true if so, false if not.
	
	OBJECT is any Object.

...............................................................................

BROWSECONTAINER(CONTAINER)

	Executes the onContainerBrowse() command blocks on all objects owned by a
	particular Container. The order is not guaranteed.
	
	CONTAINER can be any Container object.
	
	BROWSECONTAINER returns no values after execution, so it cannot be used in 
	expressions.

...............................................................................

BROWSEPLAYER(PLAYER)

	Executes the onPlayerBrowse() command blocks on all objects owned by a
	particular Player. The order is not guaranteed.
	
	PLAYER can be any Player object, including "player", which is the currently
	focused player.
	
	BROWSEPLAYER returns no values after execution, so it cannot be used in 
	expressions.

...............................................................................

BROWSEROOM(ROOM)

	Executes the onRoomBrowse() command blocks on all objects owned by a
	particular Room. The order is not guaranteed.
	
	ROOM can be any Room object, including "room", which is the currently
	focused room.
	
	BROWSEPLAYER returns no values after execution, so it cannot be used in 
	expressions.

...............................................................................
.................................   STATE   ...................................
...............................................................................

CURRENTPLAYERIS(PLAYER)

	Checks if the currently focused Player is PLAYER.
	
	Returns 1 if so, 0 if not.
	
	PLAYER can be any Player object, including "player", which is the currently
	focused player.	

...............................................................................

CURRENTROOMIS(ROOM)

	Checks if the currently focused Room is ROOM.
	
	Returns 1 if so, 0 if not.
	
	ROOM can be any Room object, including "room", which is the currently
	focused room.

...............................................................................

SETPLAYER(PLAYER)

	Switches focus from one Player to PLAYER. 
	
	If PLAYER is the current Player, this does nothing.

	PLAYER can be any Player object, including "player", which is the currently
	focused player.	
	
	Note: Since Players hold the current Room state, the current room may
	change due to this!

...............................................................................

SETROOM(ROOM)

	Switches focus from one Room to ROOM. 
	
	If ROOM is the current Room, this does nothing.

	ROOM can be any Room object, including "room", which is the currently
	focused room.
	
	This function will discard a Room stack being built/manipulated by 
	PUSHROOM(ROOM) and POPROOM().

...............................................................................

PUSHROOM(ROOM)

	Switches focus from one Room to ROOM, keeping the previous room on the
	room stack. Returning to the previous room requires the use of POPROOM().
	
	The current Room is switched to ROOM.

	ROOM can be any Room object, including "room", which is the currently
	focused room.

...............................................................................

POPROOM()

	Switches focus from the current room to the previous one on the room stack,
	created	by PUSHROOM(ROOM).
	
	Calling this without any other rooms on the stack results in an ERROR.

...............................................................................

SWAPROOM()

	Switches focus from the current room to ROOM, preserving the previous rooms
	on the stack created by PUSHROOM(ROOM).
	
	This is equivalent to calling:
	POPROOM();
	PUSHROOM(ROOM);
	
	Calling this without any other rooms on the stack results in an ERROR.

...............................................................................
................................   CASTING   ..................................
...............................................................................

ASBOOLEAN(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns VALUE as a boolean-typed value. Generally, if the value is nonzero
	or a non-empty string or is Infinity, it is "true."
	
	Note that type promotion is automatic in expressions.
	
	Examples:
	ASBOOLEAN(0) returns false
	ASBOOLEAN(5) returns true
	ASBOOLEAN(5.2) returns true
	ASBOOLEAN(0.0) returns false
	ASBOOLEAN("") returns false
	ASBOOLEAN("words") returns true

...............................................................................

ASINT(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns VALUE as an integer-typed value. If the value is a floating-point
	value (or parses to a floating-point value), it will chop the mantissa.
	If VALUE cannot be parsed as an integer (such as a string that contains 
	special characters), this returns 0.
	
	Note that type promotion is automatic in expressions.
	
	Examples:
	ASINT(5) returns 5
	ASINT(5.2) returns 5
	ASINT("5") returns 5
	ASINT("-10") returns -10
	ASINT("5.2") returns 5
	ASINT("words") returns 0

...............................................................................

ASFLOAT(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns VALUE as an floating-point-typed value. If the value is an integer,
	it is promoted to floating-point. If VALUE cannot be parsed as a 
	floating-point number (such as a string that contains special characters), 
	this returns NaN (not a number).
	
	Note that type promotion is automatic in expressions.

	Examples:
	ASFLOAT(5) returns 5.0
	ASFLOAT(5.2) returns 5.2
	ASFLOAT("5") returns 5.0
	ASFLOAT("-10") returns -10.0
	ASFLOAT("5.2") returns 5.2
	ASFLOAT("words") returns NaN

...............................................................................

ASSTRING(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns VALUE as a string-typed value.
	
	Note that type promotion is automatic in expressions.

	Examples:
	ASSTRING(5) returns "5"
	ASSTRING(5.2) returns "5.2"
	ASSTRING("5") returns "5"
	ASSTRING("-10") returns "-10"
	ASSTRING("5.2") returns "5.2"
	ASSTRING("words") returns "words"

...............................................................................
..................................   MATH   ...................................
...............................................................................

FLOOR(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns an integer-typed value that is the mathematical floor of VALUE.
	
	Examples:
	FLOOR(5) returns 5
	FLOOR(5.2) returns 5
	FLOOR(-5.2) returns -6

...............................................................................

CEILING(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns an integer-typed value that is the mathematical ceiling of VALUE.
	
	Examples:
	CEILING(5) returns 5
	CEILING(5.2) returns 6
	CEILING(-5.2) returns -5

...............................................................................

ROUND(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns an integer-typed value that is the result of rounding VALUE to the
	nearest integer (banker's rounding).
	
	Examples:
	ROUND(5) returns 5
	ROUND(5.2) returns 5
	ROUND(5.5) returns 6
	ROUND(-5.2) returns -5

...............................................................................

FIX(VALUE1, VALUE2)

	VALUE1 is any expression that results in a value being returned.
	VALUE2 is any expression that results in a value being returned.
	
	Returns a floating-point-typed value that is the result of rounding VALUE 
	to the nearest amount of decimal places specified by VALUE2.
	
	FIX(VALUE1, 0) is equivalent to ASFLOAT(ROUND(VALUE1)).
	
	Examples:
	FIX(5.4, 0) returns 5.0
	FIX(5.25, 1) returns 5.3
	FIX(5.5, 3) returns 5.5
	FIX(-5.2, 0) returns -5.0

...............................................................................

SIN(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns a floating-point-typed value that is equivalent to the SINE of
	VALUE. Assumes VALUE is in radians.
	
...............................................................................

COS(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns a floating-point-typed value that is equivalent to the COSINE of
	VALUE. Assumes VALUE is in radians.
	
...............................................................................

TAN(VALUE)

	VALUE is any expression that results in a value being returned.
	
	Returns a floating-point-typed value that is equivalent to the TANGENT of
	VALUE. Assumes VALUE is in radians.
	
...............................................................................

TIME()

	Returns an integer-typed value that is equivalent to the current time in
	milliseconds since the epoch, or the midnight of:
	January 1, 1970, GMT +0000.

...............................................................................

RANDOM(VALUE)

	Returns a random integer-typed value between 0 and the floor of VALUE,
	but not the floor of VALUE.
	
	For example, RANDOM(10) returns a number between 0 and 9, inclusive.

...............................................................................

FRANDOM()

	Returns a random floating-point-typed value between 0.0 and 1.0.

...............................................................................

GRANDOM()

	Returns a random floating-point-typed value distributed inside a normal 
	Gaussian bell curve.

...............................................................................

PI()

	Returns 3.141592653589793, or whatever this implementation of TAME 
	defines the mathematical constant PI as.

E()

	Returns 2.718281828459045, or whatever this implementation of TAME 
	defines the mathematical constant E as.

...............................................................................
................................   STRINGS   ..................................
...............................................................................

FORMATDATE(VALUE, VALUE2)

	Returns a string-typed value that is a textual representation of a 
	date/time.

	VALUE is an integer value describing a time in milliseconds since the 
	epoch.
	VALUE2 is a pattern expression describing how to format the time.
	
	The formatting expression is the same as Java's SimpleDateFormat patterns.
	(http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html)

...............................................................................

STRCONTAINSPATTERN(VALUE, VALUE2)

	Checks for the existence of a regular-expression pattern in a string-typed
	value.

	Returns 1 if VALUE contains the pattern specified by VALUE2, 0 if not.
	
	VALUE is the string that will be checked.
	VALUE2 is the expression.

...............................................................................

STRCONTAINS(VALUE, VALUE2)

	Checks for the existence of a substring pattern in a string-typed value.

	Returns 1 if VALUE contains the string specified by VALUE2, 0 if not.
	
	VALUE is the string that will be checked.
	VALUE2 is the substring.

...............................................................................

STRCONTAINSTOKEN(VALUE, VALUE2)

	Checks for the existence of a token pattern in a string-typed value.
	A "token" is this case is a string that is a whole word or whitespace-
	broken piece of text.

	Returns 1 if VALUE contains the token specified by VALUE2, 0 if not.
	
	VALUE is the string that will be checked.
	VALUE2 is the token.

	For example:
	STRCONTAINSTOKEN("I ate the apples", "apples") returns 1.
	STRCONTAINSTOKEN("I ate the apples", "apple") returns 0.


===============================================================================
============================== TAME EXPRESSIONS ===============================
===============================================================================

TAME's mathematical expression syntax is "infix," which is just a fancy way to
say, "how humans read it." An example expression looks like:

z = x + y;

Which assigns z the value of the variable x's value plus y's value. Variable
value is assessed when the expression is executed or evaluated.

Expressions can be inside function calls, and functions that return values can
be INSIDE expressions:

x = SIN( PI() / 2 );

Type promotion is automatic in expressions, and is heavily influenced by
order-of-operations and operator precedence. In the following:

str = "The value of 1 plus 2 is " + (1+2);

The variable "str" evaluates to a String-type with the value:

The value of 1 plus 2 is 3

Note the use of parenthesis. If they were not there, it would equal:

The value of 1 plus 2 is 12

Which was caused by how the operator "+" treats strings.

...............................................................................

Type promotion goes from Integer to Float to String. Unless noted otherwise,
type combination occurs this way with binary operators:

Integer AND Integer -> Integer
Integer AND Float -> Float
Integer AND String -> String
Float AND Integer -> Float
Float AND Float -> Float
Float AND String -> String
String AND Integer -> String
String AND Float -> String
String AND String -> String

Standard sizes for Integers and Floats are 64-bit precision. Strings can be 
any length up to 2^31 characters.

Each operator has use cases with strings. Be mindful of them.

...............................................................................
............................... UNARY OPERATORS ...............................
...............................................................................

ABSOLUTE
	+

Coverts numerical values to their positive value.

Examples:
	+85 -> 85
	+(-54) -> 54
	+4.7 -> 4.7

...............................................................................

NEGATE
	-

Converts numerical values to their opposite sign.

Examples:
	-4 -> -4
	-8.9 -> -8.9
	-(-5) -> 5

...............................................................................

LOGICAL NOT
	!

Performs a logical "not" operation on a value. Nonzero values and strings that
are not empty are considered "true" and Zero values and empty strings are 
"false," for the sake of boolean arithmetic. Always returns a boolean value.

Examples:
	!4 -> false
	!0 -> true
	!9.345 -> false
	!"stuff" -> false
	!"" -> true

...............................................................................

NOT
	~

Performs a "bitwise" NOT operation on a numerical value. Normally, this returns
the "two's complement" of the value. If a Float value, this uses its raw bits 
for NOT-ing.

Examples:
	~4 -> -5
	~-6 -> 5

...............................................................................
.............................. BINARY OPERATORS ...............................
...............................................................................

ADD
	+

Performs an addition of two operands. Numerical values are added together. If
one of the operands is a string, the values are concatenated together as though
they were both strings.

Examples:
	4 + 5 -> 9
	3 + -2 -> 1
	4.3 + 2.1 -> 6.4
	5 + 4.2 -> 9.2
	"to" + "gether" -> "together"
	"Ice" + 9 -> "Ice9"
	"TAME" + 1.0 -> "TAME1.0"

...............................................................................

SUBTRACT
	-

Performs a subtraction of the second operand from the first. 

Examples:
	3 - 2 -> 1
	5 - 9 -> -4
	4.5 - 2.6 -> 1.9
	5 - 0.5 -> 4.5
	4.07 - "4.0" -> 0.07

...............................................................................

MULTIPLY
	*

Performs a multiplication of the first operand by the second operand. 

Examples:
	5 * 4 -> 20
	4.2 * 3 -> 12.6
	0.5 * 0.5 -> 0.25
	-3 * 0.5 -> -1.5

...............................................................................

DIVIDE
	/

Performs division using two operands. The first operand is divided by the 
second. If two numbers, and the second operand is 0, this returns Infinity. 

Examples:
	5 / 2 -> 2
	5 / 2.0 -> 2.5
	10.0 / 0.5 -> 20.0
	0 / 4 -> 0
	4 / 0 -> Infinity

...............................................................................

MODULAR DIVIDE
	%

Performs modular division (modulo) using two operands. The first operand is
divided by the second, and the remainder is returned. 

Examples:
	5 % 2 -> 1
	5 % 2.0 -> 1.0
	10.0 % 3.5 -> 3.0
	0 % 4 -> 0
	4 % 0 -> Infinity

...............................................................................

AND
	&

	[FINISH]
	
===============================================================================
==================================== CUES =====================================
===============================================================================

Cues are placed in the server response and are executed/processed in the 
order that they were added to the response (the order that the client 
receives).

Clients that do not understand a cue name should ignore it. Cues must
be understood regardless of letter case.

[ALL VERSIONS]

text - 		CONTENT is output at the client. Used for narration and 
			messages.
textf - 	CONTENT is output at the client, with formatting to change output 
			appearance. Used for narration and messages.
pause -		CONTENT is ignored. Client will wait for a response from the 
			user before proceeding to the next cue to process.
wait - 		CONTENT is an integer value. Client should pause for CONTENT 
			milliseconds before proceeding to the next cue to process.
			If CONTENT is a string, a base-10 integer value should be 
			parsed from it. if it is a double, it should be cast to an
			integer.
trace -		CONTENT is the TRACE message. If the server is executing in a 
			debugging mode, TRACE cues may be output. The client should
			report these somehow, for debugging purposes.
tip -		CONTENT is the TIP message. These can be sent by the client in 
			order to inform the player of certain things. They are meant to
			be asides, intended to either be dismissed or ignored entirely 
			by the player.
info -		CONTENT is the INFO message. These can be sent by the client in 
			order to inform the player of certain things. They are meant to
			be asides, intended to be dismissible by the player.
error -		CONTENT is the ERROR message. The server will send these cues
			in a response if an error occurs during module execution.
			Clients MUST report this to the user in some way. Errors
			are not fatal, and the client does not need to terminate should
			it receive one.
fatal -		CONTENT contains a FATAL error message. The server will send 
			these cues in a response if a fatal error occurs during module 
			execution. Not only must clients report these errors to the 
			client, but they must also declare the session invalid. It
			is safe to assume that the server context of the module is 
			considered void. 
quit -		Tells the client to cease sending requests and enter the QUIT
			state. The server context of the module is considered void. 

