/*******************************************************************************
 * Copyright (c) 2009-2013 Black Rook Software
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 *  
 * Contributors:
 *     Matt Tropiano - initial API and implementation
 ******************************************************************************/
package net.mtrop.tame;

import net.mtrop.tame.context.TAMEModuleContext;
import net.mtrop.tame.context.TElementContext;
import net.mtrop.tame.context.TObjectContext;
import net.mtrop.tame.context.TPlayerContext;
import net.mtrop.tame.context.TRoomContext;
import net.mtrop.tame.context.TWorldContext;
import net.mtrop.tame.exception.ArithmeticStackStateException;
import net.mtrop.tame.exception.ModuleExecutionException;
import net.mtrop.tame.interrupt.ErrorInterrupt;
import net.mtrop.tame.struct.Value;

import com.blackrook.commons.hash.CaseInsensitiveHashMap;
import com.blackrook.commons.linkedlist.Queue;
import com.blackrook.commons.linkedlist.Stack;

/**
 * Request object generated by the engine to be interpreted and then
 * have a response returned back. 
 * @author Matthew Tropiano
 */
public class TAMERequest implements TAMEConstants
{
	/** Hashtable of header info. */
	private CaseInsensitiveHashMap<String> header;
	/** The input message. */
	private String inputMessage;
	/** Is the trace enabled? */
	private boolean trace;

	/** Belayed action queue. */
	private Queue<TAMEActionItem> actionQueue;

	/** Module. */
	private TAMEModuleContext moduleContext;
	/** Arithmetic stack. */
	private Stack<Value> valueStack;
	/** Context stack. */
	private Stack<TElementContext<?>> contextStack;
	
	/**
	 * Creates a new request object.
	 */
	TAMERequest()
	{
		inputMessage = null;
		trace = false;
		header = new CaseInsensitiveHashMap<String>(3);
		
		actionQueue = new Queue<TAMEActionItem>();
		
		moduleContext = null;
		valueStack = new Stack<Value>();
		contextStack = new Stack<TElementContext<?>>();
	}

	/**
	 * Sets a header value assigned to a key.
	 * The key is case-insensitive, and setting a value with an existing key will
	 * replace the existing key's value.
	 * @param key a key.
	 * @param value	the corresponding value.
	 */
	public void setHeader(String key, String value)
	{
		header.put(key, value);
	}

	/**
	 * Gets the header value assigned to a key.
	 * The key is case-insensitive.
	 * @param key	a key.
	 * @return the corresponding value, or null if the header value was not set.
	 */
	public String getHeader(String key)
	{
		return header.get(key);
	}

	/**
	 * Sets the request's input message.
	 * This gets interpreted by the TAME virtual machine.
	 */
	public void setInputMessage(String inputMessage)
	{
		this.inputMessage = inputMessage;
	}

	/**
	 * Gets the request's input message.
	 * This gets interpreted by the TAME virtual machine.
	 */
	public String getInputMessage()
	{
		return inputMessage;
	}

	/**
	 * Is this also a tracing request?
	 */
	public boolean isTrace()
	{
		return trace;
	}

	/**
	 * Sets if trace is enabled.
	 */
	public void setTrace(boolean trace)
	{
		this.trace = trace;
	}
	
	/**
	 * Adds an action item to the queue to be processed later.
	 */
	public void addActionItem(TAMEActionItem item)
	{
		actionQueue.enqueue(item);
	}

	/**
	 * Dequeues an action item from the queue to be processed later.
	 */
	public TAMEActionItem getActionItem()
	{
		return actionQueue.dequeue();
	}

	/**
	 * Dequeues an action item from the queue to be processed later.
	 */
	public boolean hasActionItems()
	{
		return !actionQueue.isEmpty();
	}

	/**
	 * Gets the module context that this affects. 
	 */
	public TAMEModuleContext getModuleContext()
	{
		return moduleContext;
	}
	
	/**
	 * Sets the module to be affected. 
	 */
	public void setModule(TAMEModuleContext module)
	{
		this.moduleContext = module;
	}
	
	/**
	 * Pushes an element context value onto the context stack.
	 * @param value the value to push.
	 */
	public void pushContext(TElementContext<?> context)
	{
		contextStack.push(context);
	}
	
	/**
	 * Pops an element context value off of the context stack.
	 */
	public TElementContext<?> popContext()
	{
		return contextStack.pop();
	}

	/**
	 * Returns the top of the context stack.
	 */
	public TElementContext<?> peekContext()
	{
		return contextStack.peek();
	}
	
	/**
	 * Pushes a value onto the arithmetic stack.
	 * @param value the value to push.
	 */
	public void pushValue(Value value)
	{
		valueStack.push(value);
	}
	
	/**
	 * Pops a value off the arithmetic stack.
	 * @throws ArithmeticStackStateException if the stack is empty.
	 */
	public Value popValue()
	{
		if (valueStack.isEmpty())
			throw new ArithmeticStackStateException("Attempt to pop an empty arithmetic stack.");
		return valueStack.pop();
	}
	
	/**
	 * Checks if the arithmetic stack is empty.
	 * Should be called after a full request is made.
	 * @throws ArithmeticStackStateException if the stack is NOT empty.
	 */
	public void checkStackClear()
	{
		if (!valueStack.isEmpty())
			throw new ArithmeticStackStateException("Arithmetic stack is not empty.");
	}
	
	/**
	 * Resolves a world context.
	 * @return the context resolved.
	 */
	public TWorldContext resolveWorld()
	{
		return getModuleContext().getWorldContext();
	}

	/**
	 * Resolves a player context.
	 * @param playerIdentity the player identity.
	 * @return the context resolved.
	 * @throws ErrorInterrupt if no current player when requested.
	 * @throws ModuleExecutionException if the non-current player identity cannot be found.
	 */
	public TPlayerContext resolvePlayer(String playerIdentity) throws ErrorInterrupt
	{
		TPlayerContext context = null;
		if (playerIdentity.equals(IDENTITY_CURRENT_PLAYER))
		{
			context = getModuleContext().getCurrentPlayerContext();
			if (context == null)
				throw new ErrorInterrupt("Current player context called with no current player!");
		}
		else
		{
			context = getModuleContext().getPlayerContextByIdentity(playerIdentity);
			if (context == null)
				throw new ModuleExecutionException("Expected player '%s' in module context!", playerIdentity);
		}
		
		return context;
	}

	/**
	 * Resolves a room context.
	 * @param roomIdentity the roomIdentity.
	 * @return the context resolved.
	 * @throws ErrorInterrupt if no current room when requested.
	 * @throws ModuleExecutionException if the non-current room identity cannot be found.
	 */
	public TRoomContext resolveRoom(String roomIdentity) throws ErrorInterrupt
	{
		TRoomContext context = null;
		if (roomIdentity.equals(IDENTITY_CURRENT_ROOM))
		{
			context = getModuleContext().getCurrentRoomContext();
			if (context == null)
				throw new ErrorInterrupt("Current room context called with no current room!");
		}
		else
		{
			context = getModuleContext().getRoomContextByIdentity(roomIdentity);
			if (context == null)
				throw new ModuleExecutionException("Expected room '%s' in module context!", roomIdentity);
		}
		
		return context;
	}

	/**
	 * Resolves a object context.
	 * @param objectIdentity the object identity.
	 * @return the context resolved.
	 * @throws ModuleExecutionException if object not found.
	 */
	public TObjectContext resolveObject(String objectIdentity) throws ErrorInterrupt
	{
		TObjectContext context = getModuleContext().getObjectContextByIdentity(objectIdentity);
		if (context == null)
			throw new ModuleExecutionException("Expected object '%s' in module context!", objectIdentity);
		return context;
	}

	/**
	 * Resolves a variable from the topmost element context.
	 * @param variableName the variable name.
	 * @return the value resolved.
	 */
	public Value resolveVariableValue(String variableName)
	{
		return peekContext().getValue(variableName);
	}

	/**
	 * Resolves a variable from the world context element.
	 * @param variableName the variable name.
	 * @return the value resolved.
	 */
	public Value resolveWorldVariableValue(String variableName)
	{
		return resolveWorld().getValue(variableName);
	}

	/**
	 * Resolves a variable from a player context element.
	 * @param playerIdentity a player identity.
	 * @param variableName the variable name.
	 * @return the value resolved.
	 * @throws ErrorInterrupt 
	 */
	public Value resolvePlayerVariableValue(String playerIdentity, String variableName) throws ErrorInterrupt
	{
		return resolvePlayer(playerIdentity).getValue(variableName);
	}

	/**
	 * Resolves a variable from a room context element.
	 * @param roomIdentity a room identity.
	 * @param variableName the variable name.
	 * @return the value resolved.
	 */
	public Value resolveRoomVariableValue(String roomIdentity, String variableName) throws ErrorInterrupt
	{
		return resolveRoom(roomIdentity).getValue(variableName);
	}

	/**
	 * Resolves a variable from an object context element.
	 * @param objectIdentity an object identity.
	 * @param variableName the variable name.
	 * @return the value resolved.
	 */
	public Value resolveObjectVariableValue(String objectIdentity, String variableName) throws ErrorInterrupt
	{
		return resolveObject(objectIdentity).getValue(variableName);
	}

}
