/*******************************************************************************
 * Copyright (c) 2015-2019 Matt Tropiano
 * This program and the accompanying materials are made available under the 
 * terms of the GNU Lesser Public License v2.1 which accompanies this 
 * distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 * 
 * See AUTHORS.TXT for full credits.
 ******************************************************************************/
package com.tameif.tame;

import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

import com.tameif.tame.element.context.TElementContext;
import com.tameif.tame.exception.ArithmeticStackStateException;
import com.tameif.tame.lang.TraceType;
import com.tameif.tame.lang.Value;

/**
 * Request object generated by the engine to be interpreted and then
 * have a response returned back. 
 * @author Matthew Tropiano
 */
public class TAMERequest
{
	private static final Set<TraceType> NO_TRACE_TYPES = new HashSet<>();
	private static final Set<TraceType> ALL_TRACE_TYPES = new HashSet<TraceType>()
	{
		private static final long serialVersionUID = -7933024056207369672L;
		{
			for (TraceType t : TraceType.values())
				add(t);
		}
	};
	
	/** The input message. */
	private String inputMessage;
	/** Is the trace enabled, and if so, for which types? */
	private Set<TraceType> traceTypes;

	/** Belayed action queue. */
	private Queue<TAMECommand> commandQueue;

	/** Module. */
	private TAMEModuleContext moduleContext;
	/** Arithmetic stack. */
	private Deque<Value> valueStack;
	/** Context stack. */
	private Deque<TElementContext<?>> contextStack;
	
	/**
	 * Creates a new request object.
	 */
	private TAMERequest()
	{
		inputMessage = null;
		traceTypes = null;
		
		commandQueue = new LinkedList<>();
		
		moduleContext = null;
		valueStack = new LinkedList<Value>();
		contextStack = new LinkedList<TElementContext<?>>();
	}

	/**
	 * Creates the request object.
	 * @param moduleContext the module context.
	 * @param tracing if true, this does tracing.
	 * @return a TAMERequest a new request.
	 */
	static TAMERequest create(TAMEModuleContext moduleContext, boolean tracing)
	{
		return create(moduleContext, null, tracing);
	}
	
	/**
	 * Creates the request object.
	 * @param moduleContext the module context.
	 * @param types the types to trace.
	 * @return a TAMERequest a new request.
	 */
	static TAMERequest create(TAMEModuleContext moduleContext, TraceType ... types)
	{
		return create(moduleContext, null, types);
	}
	
	/**
	 * Creates the request object.
	 * @param moduleContext the module context.
	 * @param input the client input query.
	 * @param tracing if true, this does tracing.
	 * @return a TAMERequest a new request.
	 */
	static TAMERequest create(TAMEModuleContext moduleContext, String input, boolean tracing)
	{
		TAMERequest out = new TAMERequest();
		out.moduleContext = moduleContext;
		out.inputMessage = input;
		out.traceTypes = tracing ? ALL_TRACE_TYPES : NO_TRACE_TYPES;
		return out;
	}
	
	/**
	 * Creates the request object.
	 * @param moduleContext the module context.
	 * @param input the client input query.
	 * @param types the types to trace.
	 * @return a TAMERequest a new request.
	 */
	static TAMERequest create(TAMEModuleContext moduleContext, String input, TraceType ... types)
	{
		TAMERequest out = new TAMERequest();
		out.moduleContext = moduleContext;
		out.inputMessage = input;
		if (types.length == 0)
			out.traceTypes = NO_TRACE_TYPES;
		else
		{
			out.traceTypes = new HashSet<>();
			for (TraceType t : types)
				out.traceTypes.add(t);
		}
		return out;
	}
	
	/**
	 * Gets the request's input message.
	 * This gets interpreted by the TAME virtual machine.
	 * @return the message used in the request.
	 */
	public String getInputMessage()
	{
		return inputMessage;
	}

	/**
	 * Checks if this request is performing a specific type of trace.
	 * @param type the trace type to check.
	 * @return true if so, false if not.
	 */
	public boolean traces(TraceType type)
	{
		return traceTypes.contains(type);
	}

	/**
	 * Adds a command to the queue to be processed later.
	 * @param item the command to add.
	 */
	public void addCommand(TAMECommand item)
	{
		commandQueue.add(item);
	}

	/**
	 * Checks if this still has commands to process.
	 * @return true if so, false if not.
	 */
	public boolean hasCommands()
	{
		return !commandQueue.isEmpty();
	}

	/**
	 * Gets the module context that this affects.
	 * @return the module context. 
	 */
	public TAMEModuleContext getModuleContext()
	{
		return moduleContext;
	}
	
	/**
	 * Dequeues a command from the queue to be processed later.
	 * @return the next command to process.
	 */
	TAMECommand nextCommand()
	{
		return commandQueue.poll();
	}

	/**
	 * Pushes an element context value onto the context stack.
	 * @param context the context to push.
	 */
	void pushContext(TElementContext<?> context)
	{
		contextStack.push(context);
	}
	
	/**
	 * Removes an element context value off of the context stack and returns it.
	 * @return the element context on the stack or null if none in the stack.
	 */
	TElementContext<?> popContext()
	{
		return contextStack.pollFirst();
	}

	/**
	 * Looks at the top of the element context stack.
	 * @return the top of the context stack, or null if the stack is empty.
	 */
	TElementContext<?> peekContext()
	{
		return contextStack.peek();
	}
	
	/**
	 * Pushes a value onto the arithmetic stack.
	 * @param value the value to push.
	 */
	void pushValue(Value value)
	{
		valueStack.push(value);
	}
	
	/**
	 * Removes the topmost value off the arithmetic stack.
	 * @return the value popped off the stack or null if the stack is empty.
	 * @throws ArithmeticStackStateException if the stack is empty.
	 */
	Value popValue()
	{
		if (valueStack.isEmpty())
			throw new ArithmeticStackStateException("Attempt to pop an empty arithmetic stack.");
		return valueStack.pollFirst();
	}
	
	/**
	 * Checks if the arithmetic stack is empty.
	 * Should be called after a full request is made.
	 * @throws ArithmeticStackStateException if the stack is NOT empty.
	 */
	void checkStackClear()
	{
		if (!valueStack.isEmpty())
			throw new ArithmeticStackStateException("Arithmetic stack is not empty.");
	}

}
